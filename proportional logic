# Propositional Logic Truth Table Enumeration
# Name: Shashank Ravindra
# USN: 1BM23CS312

import itertools

# Function to evaluate propositional expressions
def pl_true(expr, model):
    if isinstance(expr, str):   # If it's a symbol
        return model[expr]
    elif isinstance(expr, tuple):
        op = expr[0]
        if op == "not":
            return not pl_true(expr[1], model)
        elif op == "and":
            return pl_true(expr[1], model) and pl_true(expr[2], model)
        elif op == "or":
            return pl_true(expr[1], model) or pl_true(expr[2], model)
        elif op == "implies":
            return (not pl_true(expr[1], model)) or pl_true(expr[2], model)
    return False

# Truth Table Entailment Algorithm
def tt_entails(KB, query):
    symbols = list(get_symbols(KB) | get_symbols(query))
    return check_all(KB, query, symbols, {})

# Get all propositional symbols used
def get_symbols(expr):
    if isinstance(expr, str):
        return {expr}
    elif isinstance(expr, tuple):
        return get_symbols(expr[1]) | (get_symbols(expr[2]) if len(expr) > 2 else set())
    return set()

def check_all(KB, query, symbols, model):
    if not symbols:  # no more symbols left
        if pl_true(KB, model):
            return pl_true(query, model)
        else:
            return True
    else:
        rest = symbols[1:]
        p = symbols[0]
        m1 = model.copy(); m1[p] = True
        m2 = model.copy(); m2[p] = False
        return check_all(KB, query, rest, m1) and check_all(KB, query, rest, m2)

# Example: Knowledge Base = (P → Q) and (P), Query = Q
KB = ("and", ("implies", "P", "Q"), "P")
query = "Q"

result = tt_entails(KB, query)

print("Name: Shashank Ravindra")
print("USN : 1BM23CS312")
print("\nKnowledge Base: (P → Q) and (P)")
print("Query: Q")
print("Does KB entail Query? :", "YES ✅" if result else "NO ❌")
